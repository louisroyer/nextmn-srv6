//go:build ignore

// Copyright 2024 Louis Royer and the NextMN-SRv6 contributors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io"
	"os"
	"strings"
)

type StateParser int

const (
	StateInit StateParser = iota
	StateCheckProcedure
	StateCheckFunction
	StateCheckNbArgs
)

type StateLine int

const (
	StateLineRead StateLine = iota
	StateLineEnd
)

func main() {
	if len(os.Args) < 2 {
		panic(fmt.Errorf("Missing SQL file as argument"))
	}
	input := os.Args[1]
	output, ok := os.LookupEnv("GOFILE")
	if !ok {
		panic(fmt.Errorf("$GOFILE not set"))
	}
	output = strings.Replace(output, ".go", "_gen.go", 1)

	var f bytes.Buffer
	if _, err := f.WriteString("// Code generated by gen.go; DO NOT EDIT.\n"); err != nil {
		panic(err)
	}
	licence := `
// Copyright 2024 Louis Royer and the NextMN-SRv6 contributors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

`
	if _, err := f.WriteString(licence); err != nil {
		panic(err)
	}
	if _, err := f.WriteString("package database\n\n"); err != nil {
		panic(err)
	}
	if _, err := f.WriteString("type procedureOrFunction struct {\n\tnum_in int\n\tnum_out int\n\tis_procedure bool\n}\n\n"); err != nil {
		panic(err)
	}
	if _, err := f.WriteString("var procedures = map[string]procedureOrFunction{\n"); err != nil {
		panic(err)
	}
	fr, err := os.OpenFile(input, os.O_RDONLY, 0)
	if err != nil {
		panic(err)
	}
	defer fr.Close()
	scanner := bufio.NewScanner(fr)
	stateParser := StateInit
	nb_in := 0
	nb_out := 0
	for scanner.Scan() {
		stateLine := StateLineRead
		line := scanner.Text()
		for stateLine == StateLineRead {
			switch stateParser {
			case StateInit:
				nb_in = 0
				nb_out = 0
				stateParser = StateCheckProcedure
			case StateCheckProcedure:
				psuffix, ok := strings.CutPrefix(line, "CREATE OR REPLACE PROCEDURE ")
				if !ok {
					stateParser = StateCheckFunction
					continue
				}
				psplit := strings.Split(psuffix, "(")
				pname := psplit[0]
				if _, err = f.WriteString(fmt.Sprintf("\t\"%s\": {is_procedure: true, ", pname)); err != nil {
					panic(err)
				}
				stateParser = StateCheckNbArgs
			case StateCheckFunction:
				fsuffix, ok := strings.CutPrefix(line, "CREATE OR REPLACE FUNCTION ")
				if !ok {
					stateParser = StateInit
					stateLine = StateLineEnd
					continue
				}
				psplit := strings.Split(fsuffix, "(")
				pname := psplit[0]
				if _, err = f.WriteString(fmt.Sprintf("\t\"%s\": {is_procedure: false, ", pname)); err != nil {
					panic(err)
				}
				stateParser = StateCheckNbArgs
			case StateCheckNbArgs:
				// we assume argmode is always given
				nb_out += strings.Count(line, "OUT ")
				nb_in += strings.Count(line, "IN ")
				stateLine = StateLineEnd
				if strings.HasSuffix(line, ")") {
					if _, err = f.WriteString(fmt.Sprintf("num_in: %d, num_out: %d},\n", nb_in, nb_out)); err != nil {
						panic(err)
					}
					stateParser = StateInit
				}

			default:
				panic("Unknown state")
			}
		}
	}
	if _, err = f.WriteString("}\n"); err != nil {
		panic(err)
	}

	// running go fmt
	formatted, err := format.Source(f.Bytes())
	if err != nil {
		panic(err)
	}

	fout, err := os.Create(output)
	if err != nil {
		panic(err)
	}
	defer fout.Close()
	if _, err = io.Copy(fout, bytes.NewReader(formatted)); err != nil {
		panic(err)
	}
}
