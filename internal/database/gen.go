//go:build ignore

// Copyright 2024 Louis Royer and the NextMN-SRv6 contributors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func main() {
	if len(os.Args) < 2 {
		panic(fmt.Errorf("Missing SQL file as argument"))
	}
	input := os.Args[1]
	output, ok := os.LookupEnv("GOFILE")
	if !ok {
		panic(fmt.Errorf("$GOFILE not set"))
	}
	output = strings.Replace(output, ".go", "_gen.go", 1)

	f, err := os.Create(output)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if _, err = f.WriteString("// Code generated by gen.go; DO NOT EDIT.\n"); err != nil {
		panic(err)
	}
	licence := `
// Copyright 2024 Louis Royer and the NextMN-SRv6 contributors. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.

`
	if _, err = f.WriteString(licence); err != nil {
		panic(err)
	}
	if _, err = f.WriteString("package database\n\n"); err != nil {
		panic(err)
	}
	if _, err = f.WriteString("type procedure struct {\n\tnum_in int\n\tnum_out int\n}\n\n"); err != nil {
		panic(err)
	}
	if _, err = f.WriteString("var procedures = map[string]procedure{\n"); err != nil {
		panic(err)
	}
	fr, err := os.OpenFile(input, os.O_RDONLY, 0)
	if err != nil {
		panic(err)
	}
	defer fr.Close()
	scanner := bufio.NewScanner(fr)
	type State int
	const (
		StateInit State = iota
		StatePName
	)
	state := StateInit
	nb_in := 0
	nb_out := 0
	for scanner.Scan() {
		line := scanner.Text()
		switch state {
		case StateInit:
			psuffix, ok := strings.CutPrefix(line, "CREATE OR REPLACE PROCEDURE ")
			if !ok {
				continue
			}
			psplit := strings.Split(psuffix, "(")
			pname := psplit[0]
			if _, err = f.WriteString(fmt.Sprintf("\t\"%s\": ", pname)); err != nil {
				panic(err)
			}
			state = StatePName
			if strings.HasSuffix(line, ")") {
				nb_out += strings.Count(line, "OUT ")
				nb_in += strings.Count(line, "IN ")
				if _, err = f.WriteString(fmt.Sprintf("procedure{num_in: %d, num_out: %d},\n", nb_in, nb_out)); err != nil {
					panic(err)
				}
				state = StateInit
				nb_in = 0
				nb_out = 0
			}
		case StatePName:
			nb_out += strings.Count(line, "OUT ")
			nb_in += strings.Count(line, "IN ")
			if strings.HasSuffix(line, ")") {
				if _, err = f.WriteString(fmt.Sprintf("procedure{num_in: %d, num_out: %d},\n", nb_in, nb_out)); err != nil {
					panic(err)
				}
				state = StateInit
				nb_in = 0
				nb_out = 0
			}

		default:
			panic("Unknown state")
		}
	}
	if _, err = f.WriteString("}\n"); err != nil {
		panic(err)
	}

}
